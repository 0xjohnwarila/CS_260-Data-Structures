Tests

- Adding to empty table [x]
- Adding to non-empty table [x]
- Search for key in empty table 
- Search for key in non-empty table that doesn't contain key [x]
- Search for key in non-empty table that does contain key [x]
- Remove from empty table [x]
- Remove from non-empty table [x]
- Handle collisions correctly [x]

Design V0.1.3

  Simple Version
    Same as below, but uses only linear probing and a hash function designed to create MORE
    collisions for testing.
  
  Req's
    
    1) Store a fixed size array of objects
      - Size is determined by user in construction
      - Objects must have some key, be it string or some number
    
    2) Have some add method to add an object to a unique position
      - To find unique position run key through a hashing function
      - If there is a collision, handle it according to the chosen collision
        handling method

    3) Have some set of hashing functions
      - For now just one

    4) Have consistent way of handling collisions
      - Chosen by user

    5) Return an object based on its key in as close to constant time as
       possible

    6) Keep track of number of collisions and number of objects stored
      - For analysis of performance


Collision Ideas
  If the load factor is low, use open addressing.
  If the load factor is high, use closed addressing.
  
  Linear probing
  Plus 3 rehash
  numFailedAttempts^2
  Doublehash
  
Design V1.0
  Basic Hashtable
    Store values in a vector based of an index generated by a weak hash function.
    Collisions are delt with by linear probing.
    This version is good for testing collisions because the hash function will spit out many
    collisions.
  
  Advanced Hash Table
    Store values in a 2-D vector with the first demension index generated by a strongish hash.
    Collsions are delt with by entering the second dimension and walking until a free space is found.
    This version would be better for real world use, but I would recomend using a standard lib hashTable